from PyQt6.QtCore import pyqtSignalfrom PyQt6.QtWidgets import QWidget, QGridLayout, QTextEdit, QLabel, QPushButton, QFrame, QStackedWidget, QTabWidgetfrom custom.entity import EntityClass, EntityStatefrom custom.separator import Separatorfrom tabs.optima.ampl import AMPLEnginefrom tabs.optima.objective import ObjectiveSetupfrom tabs.schema.canvas import Canvasclass Optimizer(QWidget):    # Signals:    sig_modify_connectors = pyqtSignal(dict)    # Initializer:    def __init__(self, parent: QWidget = None):        # Initialize base-class:        super().__init__(parent)        # Dictionaries:        self.var_dict = dict()        self.par_dict = dict()        self.emap     = dict()        # Editor style:        style = ("QTextEdit {"                 "border: none;"                 "border-right: 1px solid white;"                 "border-radius: 0px;"                 "}")        # Main-widgets:        self._tabwid = QTabWidget(self)        self._wstack = QStackedWidget(self)        self._editor = QTextEdit(self)        self._result = QTextEdit(self)        self._setup  = QWidget(self)        self._obj    = ObjectiveSetup(None)        self._tabwid.setTabPosition(QTabWidget.TabPosition.North)        self._editor.setStyleSheet(style)        self._result.setStyleSheet(style)        self._setup.setFixedWidth(600)        # Organize tab-widget:        self._tabwid.addTab(self._editor, "Model")        self._tabwid.addTab(self._result, "Log")        self._tabwid.addTab(QWidget(), "Analysis")        # Buttons:        self._gen = QPushButton("Generate Script")        self._run = QPushButton("Optimize")        self._run.setEnabled(False)        self._gen.pressed.connect(self.build)        self._run.pressed.connect(self.run)        # Layout:        _main_layout = QGridLayout(self)        _main_layout.setContentsMargins(0, 0, 0, 0)        _main_layout.setSpacing(0)        _main_layout.addWidget(self._setup , 0, 0, 3, 1)        _main_layout.addWidget(self._tabwid, 0, 1, 3, 1)        # Sub-layout:        _setup_layout = QGridLayout(self._setup)        _setup_layout.setContentsMargins(8, 8, 8, 8)        _setup_layout.setSpacing(12)        _setup_layout.addWidget(QLabel("OPTIMIZATION SETUP"), 0, 0, 1, 4)        _setup_layout.addWidget(self._obj, 2, 0, 1, 4)        _setup_layout.addWidget(Separator(QFrame.Shape.HLine, None, "lightgray"), 1, 0, 1, 4)        _setup_layout.addWidget(Separator(QFrame.Shape.HLine, None, "lightgray"), 3, 0, 1, 4)        _setup_layout.addWidget(self._wstack, 4, 0, 1, 4)        _setup_layout.setRowStretch(5, 10)        _setup_layout.addWidget(self._gen, 5, 2)        _setup_layout.addWidget(self._run, 5, 3)        # Signal-slot connections:        self._editor.textChanged.connect(self.auto_enable)    # Set new canvas:    def reload(self, canvas: Canvas):        # Clear dictionaries:        self.var_dict.clear()        self.par_dict.clear()        self.emap.clear()        # Clear editor and result:        self._editor.clear()        self._result.clear()        # Store canvas-reference:        self.setProperty('canvas', canvas)    # Identify the variables, parameters, and equations in the canvas and store them in dictionaries:    def build(self):        # Clear editor:        self._editor.clear()        self.var_dict.clear()        self.par_dict.clear()        self.emap.clear()        # Define sets:        var_set = set()        par_set = set()        eqn_set = set()        # Other convenience variables:        ecount = 0        ocount = 0        opt_hdrs = "# Model\n"        eqn_prfx = f"subject to equation_"        # Section declarations:        var_section = "# Variable(s):\n"        eqn_section = "# Equation(s):\n"        obj_section = "# Objective(s):\n"        par_section = "# Parameter(s):\n"        # Generate combined expressions for terminals:        for terminal, state in self.property('canvas').term_db.items():            # Skip dangling or hidden terminals:            if (                not bool(terminal.handle.label) or                not terminal.handle.connected or                not state            ):                  continue            # Define entity name:            entity_name = f"TOTAL_{terminal.handle.label}"            # Define total-flow variable:            if (                    entity_name not in var_set and                    entity_name not in par_set            ):                # If a value is assigned, define the entity as a parameter:                if  bool(terminal.handle.value):                    par_section = f"param TOTAL_{terminal.handle.label} = {terminal.handle.value};\n"                    par_set.add(entity_name)                # If not, define it as a variable:                else:                    var_section += f"var {entity_name};\n"                    var_set.add(entity_name)                # Map variable name to entity:                self.emap[entity_name] = terminal.handle                # Combine different terminals                expr = f"{entity_name}"                for _terminal, _state in self.property('canvas').term_db.items():                    if (                        _terminal.handle.label == terminal.handle.label and                        _terminal.handle.strid == terminal.handle.strid                    ):                        expr += f" - {_terminal.handle.connector().symbol}"                eqn_section += f"{eqn_prfx}{ecount}: {expr} = 0.0;\n"                ecount += 1        # Iterate through all nodes in the canvas and collect variables, parameters, and equations:        for node, state in self.property('canvas').node_db.items():            # Skip hidden nodes:            if not state: continue            n_prefix = node.uid            var_list = [                variable for variable, state in node[EntityClass.VAR].items()                 if state == EntityState.ACTIVE            ]            par_list = [                parameter for parameter, state in node[EntityClass.PAR].items()                if state == EntityState.ACTIVE            ]            for variable in var_list:                # Null-check:                if variable.connector is None:  continue                symbol = variable.connector().symbol                self.emap[symbol] = variable                # If the variable is already declared, skip processing:                if  symbol in var_set | par_set:                    continue                # Declare the variable (as a parameter if its value is defined):                if  bool(variable.value):                    par_set.add(symbol)                    par_section += f"param {symbol} = {variable.value};\n"                else:                    var_set.add(symbol)                    var_section += f"var {symbol};\n"                    # If bounds are provided, add them as equations:                    if  bool(variable.minimum):                        eqn_section += f"{eqn_prfx}{ecount}: {symbol} - {variable.minimum} >= 0.0;\n"                        ecount += 1                    if  bool(variable.maximum):                        eqn_section += f"{eqn_prfx}{ecount}: {symbol} - {variable.maximum} <= 0.0;\n"                        ecount += 1            for parameter in par_list:                # Convenience variable:                symbol = f"{n_prefix}_{parameter.symbol}"                self.emap[symbol] = parameter                # If the parameter has already been declared, skip processing:                if symbol in var_set | par_set:                    continue                # If the parameter doesn't have a value, declare it as a variable                if  bool(parameter.value):                    par_set.add(symbol)                    par_section += f"param {symbol} = {parameter.value};\n"                else:                    var_set.add(symbol)                    var_section += f"var {symbol};\n"                    # If bounds are provided, add them as equations:                    if  bool(parameter.minimum):                        eqn_section += f"{eqn_prfx}{ecount}: {symbol} - {parameter.minimum} >= 0.0;\n"                        ecount += 1                    if  bool(parameter.maximum):                        eqn_section += f"{eqn_prfx}{ecount}: {symbol} - {parameter.maximum} <= 0.0;\n"                        ecount += 1            for equation in node.substituted():                eqn_section += f"{eqn_prfx}{ecount}: {equation};\n"                eqn_set.add(equation)                ecount += 1        dictionary = self._obj.get_objectives()        opt_type   = self._obj.get_opt_type()        opt_engine = self._obj.get_engine()        objectives = dictionary.keys()        # Define objective functions:        for objective in objectives:            if bool(objective):                obj_section += f"{dictionary[objective].lower()} obj_{ocount}: {objective};\n"                ocount    += 1        # Construct model:        if opt_engine == "AMPL":            self._editor.setText(                f"{opt_hdrs}\n"                f"{par_section}\n"                f"{var_section}\n"                f"{obj_section}\n"                f"{eqn_section}"            )        elif opt_engine == "CasADi":            CasADi_model(var_set | par_set, )    def run(self):        engine = AMPLEngine()        result = engine.optimize(self._editor.toPlainText())        self._result.setText(f"AMPL Result: [{engine.result}]")        self._result.append ("-" * 36)        if engine.result == "solved":            output = str()            for key in result["var_dict"].keys():                output += f"{key}\t= {result["var_dict"][key]}\n"            for key in result["par_dict"].keys():                output += f"{key}\t= {result["par_dict"][key]}\n"            for key in result["obj_dict"].keys():                output += f"{key}\t= {result["obj_dict"][key]}\n"            self._result.append(output)            self.sig_modify_connectors.emit(result)        else:            self._result.append(engine.error)        self._tabwid.setCurrentWidget(self._result)    def auto_enable(self):        if bool(self._editor.toPlainText()):            self._run.setEnabled(True)        else:            self._run.setEnabled(False)